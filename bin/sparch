#! /usr/bin/perl
use v5.30;
use strict;
use warnings;

our @ISA = qw();

our $VERSION = '0.01';

use Getopt::Long qw(:config no_ignore_case no_auto_abbrev);
use Archive::Tar;
use MIME::Base64;
use File::Find;
use Pod::Usage;

# Return codes
sub ERR_SUCCESS { 0 }                 # Success
sub ERR_TAR { 1 }                     # Error archiving
sub ERR_OPTIONS_UNRECOGNIZED { 2 }    # Unrecognized options from GetOpt
sub ERR_FILE_NOENT { 3 }              # File or directory does not exit

my $compression;
my $temp_file = random_filename();              # Generate a random filename to be used
my $output = '';
my $script = '';
my $dir = '';
my $help = 0;
my $man = 0;
my @files;

# Check if XZ is available. If not, try BZIP2. If BZIP2 is also not available, then default to GZIP
# Note 9 means 'the best gzip compression level'
$compression = eval'COMPRESS_XZ' || eval'COMPRESS_BZIP' || 9;

# Parse options from the command line
GetOptions(
    'output|o=s' => \$output,
    'script|s=s' => \$script,
    'dir|d=s' => \$dir,
    'files|f=s{,}' => \@files,
    'help|h|?' => \$help,
    'man' => \$man
) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-exitval => 0, -verbose => 2) if $man;


# If dir is not present and files not present, then read list of files from stdin
unless( $dir || @files ) {
    my $stdin_file;
    while($stdin_file = <STDIN>) {
        chomp $stdin_file;
        push @files, $stdin_file;
    }
}

$output ||= 'out';             # If --output is not specifided, default to 'out'
my $output_file = $output . '.pl';

# Check for non-existent files and exit
my $non_existent = 0;
if(@files) {
  for(@files) { 
    unless(-e) {
      say "Non existent file $_";
      $non_existent = 1;
    }
  }
  exit ERR_FILE_NOENT;
}

# If --dir is specified, get all files from that directory. This needs to be done
if($dir){ 
    my @dirs = ($dir);      # This is necessary because 'find' takes an array while we take a scalar
    find(\&wanted, @dirs)
}

# Create the archives
my $tar = Archive::Tar->new;
say "Could not create archive: " . $tar->error unless($tar->create_archive($temp_file, $compression, @files));

# Open the "$output" file for writing
unlink $output_file;                    # First delete the output file if it already exists
open(my $output_handle, '>>', $output_file) or die "Cannot open $output_file: $!";

# Command to execute a given script after extraction.
my $execute_command = $script ? qq(do './$script';) : '';

print $output_handle <<"EOF";
#! /usr/bin/perl
use v5.30;
use strict;
use warnings;
use Archive::Tar;
use MIME::Base64;

my \$compression = "$compression";
my \$temp_file = "$temp_file";
mkdir "$output";
chdir "$output";

# Open a temporary working file
open(my \$temp_handle, '>', \$temp_file) or die "Cannot open temporary file: \$!";
binmode \$temp_handle;

# Base64-decode the data attached to this script
my \$base64_data = <DATA>;
print \$temp_handle decode_base64(\$base64_data);
close \$temp_handle;

# Decompress and extract the file archive
Archive::Tar->extract_archive(\$temp_file, \$compression);

$execute_command

unlink \$temp_file;

# Attached tar archive compressed and base64 encoded
__DATA__
EOF

open (my $temp_handle, '<', $temp_file) or die "Could not open $temp_file: $!";
binmode $temp_handle;               # This is necessary to correctly read the file in binary

while(read $temp_handle, my $buffer, 65536) {
  print $output_handle encode_base64($buffer, '');
}

close $temp_handle;           # Close the temporary file
unlink $temp_file;            # And delete it
chmod 0755, $output_file;     # Change permissions to make output file executable

# Sub routine to be used by Find::File
sub wanted {
    # Push files found unto the @files array along with the
    # other files received from the commandline options
    push @files, $File::Find::name
}


# Subroutine to generate random file names
sub random_filename {
  my $filename = '';
  my @chars = ('A' .. 'Z', 'a' .. 'z', '0' .. '9', '-', '_');
  for(1 .. 16) {
    $filename .= $chars[ int(rand(@chars))];
  }
  return $filename;
}

__END__

=head1 NAME

Sparch is a tool for creating self extracting perl archives. The resulting file is a perl script that can be run to extract the 
files in the archive.

=head1 SYNOPSIS

  sparch --dir path/to/folder --output archive --script script-to-run --files file1 file2
  sparch --help

=head1 DESCRIPTION

Sparch is used for creating self-extracting perl archives. The archive itself is created and compressed using Archive::Tar. The 
resulting archive is then base64 encoding using MIME::Base64 and attached to a perl script. 

=head1 OPTIONS

-h --help
    Displays usage help

-d --dir
    The directory that contains the file(s) to archive.

-f --files
    List of files that should be in the archive. This should be the last option if specified. Everything that follows is taken to be 
    files to be added to the archive

-o --output
  Name of the resulting archive file. Sparch attaches .pl to the name specified by this option. The resulting file is an executable 
  perl script (chmod +x). If this option is not specified, sparch uses out.pl as the name of the resulting archive file.

-s --script
  A script that is part of the archive which will be executed once the archive has been extracted. The script must be an executable 
  perl script

=head1 SEE ALSO

Mention other useful documentation such as the documentation of
related modules or operating system documentation (such as man pages
in UNIX), or any relevant external documentation such as RFCs or
standards.

If you have a mailing list set up for your module, mention it here.

If you have a web site set up for your module, mention it here.

=head1 AUTHOR

Deji Adegbite, E<lt>contact@dejiadegbite.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2022 by Deji Adegbite

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.30.3 or,
at your option, any later version of Perl 5 you may have available.


=cut